# Инструкция по работе с Git &  Инструкция по написанию текстов в MrakDown

Тут будет общая информация про git

## Выделение текстов

В MarkDown есть несколько различных способов выделить текст. 

Например, Вы можете обрамить слово (или кусок текста) звездочками (*) или нижним подчеркиванием (_) и тогда он будет написан курсивом - *вот так* или _вот так_.

Также вы можете выделить текст полужирным шрифтом, для этого необходимо обрамить текст двойными звездочками (**) или двойными подчеркиванием (__) - **полужирный текст** или __полужирный текст__.

Мы можем комбинировать разные способы выделения полужирным и курсивом. Например, вот так - _Курсивный и одновременно **полужирный текст**_.

## Работа со списками

Списки выбают нумерованными и ненумерованными. Если нам нужен нумерованный список, то мы просто пишем каждый элемент со своим номером на новой строке, а MarkDown сам его красиво оформит. Например, вот так:

1. первый элемент
2. второй элемент
3. третий элемент

Если нам нужны ненумерованные списки, то мы вместо числа (номера элемента) можем поставить +. Например, вот так:

+ Элемент
+ Элемент

## Картинки в тексте

Чтобы добавить картинку в текст необходимо использовать следующий синтаксис - ставим восклицательный знак, потом в квадратных скобках указываем текст, а в круглых - адрес файла с картинкой. Адрес относительный или абсолютный. Например, вот так:

![Эмблема картинки](Seminar1.jpg)
    

## Исключение отслеживания файлов

Если мы хотим чтобы в нашем репозитории были картинки, но они не отслеживались нужно создать файл **.gitignore**

    .gitignore

Далее в файле .gitignore прописываем символ *.jpg (общий тип расширения картинки) либо индивидуально через название конкретного файла, к примеру Seminar1.jpg

    *.jpg


## Ссылки в текста

Ссылка на [GitHub](https://github.com/)


## Создание нового репозитория

Для создания нового репозитория (инициализации) нужно ввести команду 

    git init

## Проверка состояния репозитория

Чтобы проверить текущее состояние репозитория нужно ввести команду:

    git status

Домашнее задание - Описать список команд git ... :

1. init
2. status
3. add 
4. commit
5. commit -m "message"
6. commit -a
7. commit -am
8. log
9. log  --oneline
10. log --all
11. log --oneline --all
12. diff
13. checkout


Команда **git inint** 

    git init

_Инициализация репозитория_

Создать пустой репозиторий Git или вновь инициализировать существующий можно параметром init. При инициализации он создаст скрытую папку. В ней содержатся все объекты и ссылки, которые Git использует и создаёт в истории работы над проектом.


Команда **git status** 

    git status

_Проверка статуса репозитория_

Просмотреть статус нужного репозитория можно по ключевому слову status: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.


Команда **git add**

    git add

    Пример:
    $ git add hello.txt

_Добавление отдельных файлов или всех файлов в область подготовленных файлов_

В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой add
    
  
Команда **git commit**

    git commit

_Внесение сообщений об изменении через редактор сообщений/комментариев_


Команда **git commit -m "message"**

    git commit -m "message"

_Внесение сообщений об изменении однострочным сообщением_

Флажок -m задаст commit message - комментарий разработчика. Он необходим для описания закоммиченных изменений. И здесь работает золотое правило всех комментариев в коде: «Максимально ясно, просто и содержательно обозначь написанное!»
Буквально git commit -m используется для отправки файлов в промежуточной области


Команда **git commit -a**

    git commit -a

_Добавит все файлы и создаст коммит_

Git commit с флагом -a — совершит коммит, автоматически индексируя изменения в файлах проекта. Новые файлы при этом индексироваться не будут! Удаление же файлов будет учтено.


Команда **git commit -am**

    git commit -am

_Используется для отправки файлов, которые были отслежены_

Если вы используете git commit -am, вы можете пропустить шаг git add a.txt, потому что git commit -am может отправлять отслеживаемые файлы, а a.txt уже был отслежен в начале
Т.е. вместе с коммитом мы добавляем и фиксируем все изменения. 
Пример: git commit -am "текст_сообщения".


Команда **git log**

    git log

_Просмотр истории коммитов с изменениями_

По умолчанию (без аргументов) git log перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке – последние коммиты находятся вверху. 
Отображает список последних коммитов в порядке выполнения.
В нем содержится вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны.
Показывает все коммиты от новых к старым. Для каждого коммита выводится

* хэш
* автор
+ дата 
+ сообщение (commit message)


Команда **git log --oneline**

    git log --oneline

Команда покажет все ваши коммиты только с первой частью хэша и сообщением фиксации (commit message). Каждая фиксация будет находиться в одной строке, как oneline - одна линия.
Опция oneline печатает каждую фиксацию в одной строке, что полезно, если вы смотрите на множество коммитов.


Команда **git log --all**

    git log --all

Перечисляет все коммиты, сделанные в репозитории.


Команда **git log --all --oneline**

    git log --all --oneline

Команда покажет все ваши коммиты только с первой частью хэша


Команда **git log --stat --graph**
    
    git log --stat --graph

Выводит коммиты в виде дерева, в командной строке псевдографикой. Плюс выводит список измененных файлов, печатает под каждым из коммитов список и количество измененных файлов, отображает ASCII граф с ветвлениями и историей слияний.


Команда **git log --graph**
    
    git log --graph

Выводит коммиты в виде дерева


Команда **git diff**

    git diff

_Просмотр изменений до коммита_

Можно просматривать список изменений, внесённых в репозиторий


Команда **git checkout**

    git checkout
    
Если предположить, что ваш рабочий репозиторий уже содержит существующие ветки, вы можете переключаться между этими ветками с помощью команды git checkout. 


Команда **git checkout ＜new-branch＞**

    git checkout ＜new-branch＞

Команда git checkout ＜new-branch＞ выполняет переключение на новую ветку new_branch.


Команда **git checkout -b ＜new-branch＞**

    git checkout -b ＜new-branch＞

Команда git checkout также принимает аргумент -b, который действует как вспомогательный метод, позволяя создать новую ветку и сразу переключиться на нее, набрав команду git checkout -b ＜new-branch＞


Команда **git branch**

    git branch

Чтобы узнать, какие ветки доступны и как называется текущая ветка, выполните команду git branch.


Команда **git branch new_branch**

    git branch new_branch

 С помощью команды git branch можно создать новую ветку. Когда вы захотите начать работу над новой функцией, создайте новое ответвление от ветки main/master с помощью команды git branch new_branch. Затем переключитесь на новую ветку с помощью команды git checkout new_branch


Команда **git branch -d**

    git branch -d new_branch

Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее, по правилам хорошего тона, необходимо удалить, чтобы она более не мешалась в вашем коде
Тогда используем данную команду, где флажок -d являющийся опцией команды git branch - это сокращенная версия ключевого слова --delete, предназначенного для удаления ветки, а new_branch – название ненужной нам ветки.
Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя. Если же вы все-таки попытаетесь это сделать, система отругает вас и выдаст ошибку.
Так что при удалении ветвей, обязательно переключитесь на другой branch.


Команда **git merge**

    git merge <...>
    
    git merge <сливаемая ветка>

Команда git merge выполняет слияние отдельных направлений разработки, созданных с помощью команды git branch, в единую ветку.
Слияние веток – это перенос изменений с одной ветки на другую. При этом слияние не затрагивает сливаемую ветку, то есть она остается в том же состоянии, что позволяет нам потом продолжить работу с ней.
Сливаемая ветка – та ветка, с которой мы берем изменения, чтобы влить их в целевую.
Целевая ветка – та ветка, в которую мы сливаем наши изменения.
Перед слиянеим веток нужно перейти в целевую ветку через команду git checkout new_branch.


## Удаленные репозитории

Удаленные репозитории это ...


Пока продолжил заниматься ветвлением

После первого ветвления от ветки master продолжаю инструкцию

Создал ветку new2

В ветке new2 сохраняю первый коммит 

В ветке new2 сейчас меньше данных чем в ветке new3
